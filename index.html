<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Immutability in JS</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<style>
		.img {
			width: 1200px;
			height: 600px;
		}

		.big-font > * {
			font-size: 140% !important;
		}

		.high-lighted-text {
			color:brown;
		}
		</style>

	</head>
	<body>
		<div class="reveal">
			<div class="slides">

				<section data-markdown>
					<textarea data-template>
						## Immutability in JS Immutable.js

						<img src="./assets/Imtbl.png"/>

						Note:
						Hello everyone, my topic for today is Immutability and Immutable.js library.
					</textarea>
				</section>

				<section>
					<h2>Slides</h2>
					<a href="https://mrstalon.github.io/Presentation---Immutable.js/" target="_blank">Presentation</a>

					<aside class="notes">
						Firstly, does anyone need link to the presentation?
					</aside>
				</section>

				<section>
					<span>Artem Zekov, 17-year-old</span>
					<p>RSS student</p>
					<img src="./assets/me.jpg">

					<aside class="notes">
						For the beginning, few words about me.
						I've been coding on Javascript for over a year.
						I really love this language.
						That's why I am very interested in this topic
						And That's is why will do my best to explain
						you today's topic.
					</aside>
				</section>

				<section>
					<h2>Immutable data</h2>
					<span class="fragment">A data that can't be changed once it was created</span>

					<aside class="notes">
						Let's get started with the definition of Immutable data.
					</aside>
				</section>

				<section>
					<span class="fragment fade-in">Mutable array</span>
					<span class="fragment fade-in" data-markdown>
						```javascript
						let array = [1, 2, 3, 4];
						let reversedArray = array.reverse();
						console.log(reversedArray); // [4, 3, 2, 1]
						console.log(array); // [4, 3, 2, 1]
						```
					</span>

					<aside class="notes">
						Simple example of mutability
					</aside>
				</section>

				<section>
					<h3>Problems of mutability</h3>
					<ul>
						<li class="fragment">Makes our code unpredictable</li>
						<li class="fragment">Harder to test</li>
					</ul>

					<aside class="notes">
						And here we came up with problems of mutability.
					</aside>
				</section>

				<section>
					<h3>Unpredictable code</h3>

					<span data-markdown>
						```javascript
						let array = [1, 2, 3, 4];
						// 1000 of lines of code
						// Lots of them

						function printReversedArray(array) {
							console.log(array.reverse());
						}

						// 1000000 lines of code
						// Many of them

						function calcSum(array) {
							???
						}
						```
					</span>

					<aside class="notes">
						Consider this unpredictable code.
						Imagine that you are working on a very big project....
						Unpredictability will bring you to hours of suffering through
						debugging and testing your code.
						Anyway, what is the solution of this problem?
					</aside>
				</section>

				<section>
					<img src="https://i.imgflip.com/2nn1br.jpg" title="made at imgflip.com"/>
				</section>

				<section>
					<span class="fragment fade-in">Immutable array</span>
					<span class="fragment fade-in" data-markdown>
						```javascript
						let array = new Immutable.List([1, 2, 3, 4]);
						// we create new array based on previous array
						let reversedArray = array.toJS().reverse();
						console.log(reversedArray); // [4, 3, 2, 1]
						console.log(array.toJS()); // [1, 2, 3, 4]
						```
					</span>

					<aside class="notes">
						Any mutation on array creates a new copy of it.
						That is why array and reversedArray are two
						independent arrays.
					</aside>
				</section>

				<section>
					<span>Under the hood - mutability</span>
					<div style="position: relative; height: 300px; width: 78%; margin: 0 auto;" >
						<img src="./assets/array.png" class="fragment fade-out" style="position:absolute; left: 0; right: 0;" data-fragment-index="0">
						<img src="./assets/changed-array.png" class="fragment fade-in" style="position:absolute;left: 0; right: 0;" data-fragment-index="0">
					</div>

					<aside class="notes">
						On the one hand, since in JS, variables just contain references to
						arrays and objects, any attemp to change it's values, mutate it.
						Moreover, we've got these tricky array methods that mutate original array.
					</aside>
				</section>

				<section>
					<span>Under the hood - immutability</span>
					<div style="position: relative; height: 300px; width: 78%; margin: 0 auto;" >
						<img src="./assets/im-array.png" class="fragment fade-out img" style="position:absolute; left: 0; right: 0;" data-fragment-index="0">
						<img src="./assets/changed-im-array.png" class="fragment fade-in img" style="position:absolute;left: 0; right: 0;" data-fragment-index="0">
					</div>

					<aside class="notes">
						On the other hand, we have Immutability. Significantly different
						approach to programming. Any mutation creates new copy of a D-S.
						There is no way to mutate original D-S. Only replacing it with
						new version.
					</aside>
				</section>

				<section>
					<h3>Any attempt to mutate = new copy</h3>
				</section>

				<section>
					<span data-markdown>
						```javascript
						let array = new Immutable.List([]);
						for (let i = 0; i < 10000000; i++) {
							array.push(i);
						}
						```
					</span>
					<img src="https://i.imgflip.com/2nyoib.jpg" title="made at imgflip.com" class="fragment fade-in"/>

					<aside class="notes">
						If any attemp to mutate D-S creates a new copy of it.
						Consider this code.
						As far as I concerned, we are about to create 10 millions
						Immutable lists.
						I know what you are thinking.
					</aside>
				</section>

				<section>
					<h3>Is Immutability worth using it?</h3>
					<img src="https://i.imgflip.com/2nn1y1.jpg" title="made at imgflip.com"/>

					<aside class="notes">
						That's a good question. Let's check it out!
					</aside>
				</section>

				<section>
					<h2>Copying wastes time and space :(</h2>
					<h3 class="fragment fade-in">but...</h3>
				</section>

				<section>
					<h2>There must be a better way...</h2>
				</section>

				<section>
					<h2>Persistant data structures :)</h2>
					<span>Data structures which are able to save old versions of themselves</span>

					<aside class="notes">
						Data strtuctures which are able to save old
						versions of themselves.
					</aside>
				</section>

				<section>
					<h4>Structural sharing</h4>
					<div style="position: relative; height: 300px; width: 78%; margin: 0 auto;" >
						<img src="./assets/structural-1.png" class="fragment fade-in-then-out img" style="position:absolute; left: 0; right: 0;" data-fragment-index="0">
						<img src="./assets/structural-2.png" class="fragment fade-in-then-out img" style="position:absolute;left: 0; right: 0;" data-fragment-index="1">
						<img src="./assets/structural-3.png" class="fragment fade-in-then-out img" style="position:absolute;left: 0; right: 0;" data-fragment-index="2">
						<img src="./assets/structural-4.png" class="fragment fade-in-then-out img" style="position:absolute;left: 0; right: 0;" data-fragment-index="3">
						<img src="./assets/structural-5.png" class="fragment fade-in-then-out img" style="position:absolute;left: 0; right: 0;" data-fragment-index="4">
						<img src="./assets/structural-6.png" class="fragment fade-in-then-out img" style="position:absolute;left: 0; right: 0;" data-fragment-index="5">
						<img src="./assets/structural-7.png" class="fragment fade-in-then-out img" style="position:absolute;left: 0; right: 0;" data-fragment-index="6">
						<img src="./assets/structural-8.png" class="fragment fade-in-then-out img" style="position:absolute;left: 0; right: 0;" data-fragment-index="7">
						<img src="./assets/structural-9.png" class="fragment fade-in-then-out img" style="position:absolute;left: 0; right: 0;" data-fragment-index="8">
					</div>

					<aside class="notes">
						1. Let's represent our array as a tree (put all values into the leaves of the tree)
						2. Connect them with the parent nodes and parent nodes with their parent node
						all the way up to the root node.
						3. Here is our array represented as a tree.

						How do we update something?

						In fact, we don't need to copy the entire tree, we
						just need to copy only one node that we want to change.
						For instence, let's change this very bottom left node.
						Specifically it's value 1 to something else.

						1. So we are making a copy of a this very bottom left node.
						2. Then I need to copy any of the parent nodes that were pointing to
						the node I changed
						3. I basically trace a path up towards the root node.
						4. And now I've got new root, which means - new version of D-S.


						So, instead of copying the entire array
						we just copy nodes on the way to changed node. In fact, we reuse previous state.

						That's called structural sharing because we are sharing the structure of the tree
						between the two versions.

						To sum up, structural sharing makes it possible to implement persistant
						D-S to our programming world. And it's obviously makes perfomance of
						immutable D-S very fast.
					</aside>
				</section>

				<section class="big-font">
					<span>Old versions never change :)</span>
					<p class="fragment fade-in">    (they just sit, and are)   </p>

					<aside class="notes">
						The idea here is that old versions never change. They just sit, and are.
					</aside>
				</section>

				<section class="big-font">
					<span>New versions created efficeently :D</span>
					<p class="fragment fade-in">    (with a help of structural sharing)   </p>
				</section>

				<section>
					<h4>Libraries for immutability in JS</h4>
					<img src="./assets/Immutable-js.png" class="fragment fade-in">
					<img src="./assets/mori-js.png" class="fragment fade-in">

					<aside class="notes">
						Now I will tell you the most popular libraries
						that brings immutability to JS.
					</aside>
				</section>

				<section>
					<img src="./assets/array-difference.png">
					<img src="./assets/object-difference.png">

					<aside class="notes">
						Astonishing part here is that Mori.js is even faster than native JS.
						Immutable.js has great Array perfomance, but according to objects
						Immutable.js is not as good as native JS and Mori.
					</aside>
				</section>

				<section>
					<h3>Let's dive into Immutable.js!</h3>
					<img src="https://i.imgflip.com/2o2o7i.jpg" title="made at imgflip.com"/>

					<aside class="notes">
						Now when we are familiar with immutability principles
						we will dive into usage of Immutable.js
					</aside>
				</section>

				<section>
					<h4>Data Structures provided by Immutable.js</h4>
					<ul>
						<li class="fragment fade-in">List</li>
						<li class="fragment fade-in">Map</li>
						<li class="fragment fade-in">Stack</li>
						<li class="fragment fade-in">Set</li>
					</ul>
				</section>

				<section>
					<h2>Immutable <span class="high-lighted-text">Map</span> useful methods:</h2>
					<ul>
						<li class="fragment">Map(jsObject)</li>
						<li class="fragment">Map.isMap(maybyMap) <span class="high-lighted-text">--> true/false</span></li>
						<li class="fragment">set(key, value) <span class="high-lighted-text">--> new map</span></li>
						<li class="fragment">get(key) <span class="high-lighted-text">--> value</span></li>
						<li class="fragment">delete(key) <span class="high-lighted-text">--> map without key</span></li>
						<li class="fragment">toJS() <span class="high-lighted-text">--> JS object</span></li>
					</ul>
				</section>

				<section>
					<h4>Map usage example</h4>
					<span data-markdown class="fragment fade-in">
						```javascript
						const { Map } = require('immutable');
						let map1 = Map({a:1, b:2, c:3});
						let map2 = map1.set('b', 50);
						console.log( map1.get('b') ); // 2
						console.log( map2.get('b') ); // 50

						let jsObject = map2.toJS();
						console.log(jsObject); // { a: 1, b: 50, c: 3 }

						console.log(Map.isMap(map1)); // true
						console.log(Map.isMap(jsObject)); // false

						let mapWithoutBprop = map2.delete('b');
						console.log(mapWithoutBprop.toJS()); // { a: 1, c: 3 }
						```
					</span>
				</section>

				<section>
					<h2>Immutable <span class="high-lighted-text">List</span> useful methods and props:</h2>
					<ul>
						<li class="fragment">List(jsArray)</li>
						<li class="fragment">List.isList(maybyList) <span class="high-lighted-text">--> true/false</span></li>
						<li class="fragment">size <span class="high-lighted-text">--> list length</span></li>
						<li class="fragment">set(index, value) <span class="high-lighted-text">--> new list</span></li>
						<li class="fragment">delete(index) <span class="high-lighted-text">--> new list without list[index]</span></li>
						<li class="fragment">insert(index, value) <span class="high-lighted-text">--> new list</span></li>
						<li class="fragment">push(value) <span class="high-lighted-text">--> new list</span></li>
						<li class="fragment">pop() <span class="high-lighted-text">--> new list</span></li>
						<li class="fragment">toJS() <span class="high-lighted-text">--> JS array</span></li>
					</ul>
				</section>

				<section>
					<h4>Immutable List usage</h4>
					<span data-markdown class="fragment fade-in">
						```javascript
							const { List } = require('immutable');
							let list1 = List([1, 2, 3, 4]);
							let arrayFromList = list1.toJS();

							console.log(arrayFromList); // [1, 2, 3, 4]
							console.log(List.isList(list1)); // true
							console.log(List.isList(arrayFromList)); // false

							let list2 = list1.push(5).delete(0);
							console.log(list2.toJS()); // [2, 3, 4, 5]
							console.log(list2.size); // 4
						```
					</span>
				</section>

				<section>
					<h3>Undo-Redo Demo with immutable.js</h3>
					<a href="https://mrstalon.github.io/undo-redo-with-immutable.js/" target="_blank">Website demo</a>
					<p><a href="https://github.com/mrstalon/undo-redo-with-immutable.js/tree/gh-pages" target="_blank">Source code</a></p>

					<aside class="notes">
						After I'd explored Immutability and Immutable.js I dediced to make something
						with a use of my new knowledge. Specifically, I decided to create undo-redo example
						with Immutable.js. Two links.

						Let's have a brief look to my demo and then we will get to the source code.
					</aside>
				</section>

				<section>
					<img src="./assets/undo-code-2.png">
				</section>

				<section>
					<img src="./assets/undo-code-3.png">
				</section>

				<section>
					<h3>It's that simple!!</h3>
					<ul>
						<li class="fragment">Create <span class="high-lighted-text">history</span> array that contains states</li>
						<li class="fragment">Create <span class="high-lighted-text">operation</span> wrapper for mutations</li>
						<li class="fragment">Wrap all mutations in <span class="high-lighted-text">operation</span> wrapper</li>
						<li class="fragment">Enjoy undo-redo feature!!</li>
					</ul>

					<aside class="notes">
						Note that any mutation in your code should return
						a new version of state
					</aside>
				</section>

				<section>
					<img src="https://i.imgflip.com/2o3x5f.jpg" title="made at imgflip.com"/>

					<aside class="notes">
						Now since you are familiar with immutability principles and Immutable.js
						library, you will be able to choose from two options and I hope
						you will make right decision, THANK YOU.
					</aside>
				</section>

				<section>
					<h3>Thank you!!!</h3>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
